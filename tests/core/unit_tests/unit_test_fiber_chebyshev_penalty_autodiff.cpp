
/// \file unit_test_fiber_base.cpp
/// \brief Unit tests for FiberChebyshevPenalty class

// C++ includes
#include <iostream>
#include <memory>
#include <string>
#include <vector>

// skelly includes
#include <fiber_chebyshev_penalty_autodiff.hpp>
#include <msgpack.hpp>

// test files
#include "./mpi_environment.hpp"

// Test the penalty version constructor
TEST(FiberChebysehvPenaltyAutodiff, real_constructor) {
    // Create a fiber object
    int N = 20;
    int NT = N - 2;
    int Neq = N - 4;
    int NTeq = NT - 2;
    double mlength = 1.0;
    FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);

    // Now create our fiber in XYT
    Eigen::VectorXd init_X = Eigen::VectorXd::Zero(FS.n_nodes_);
    Eigen::VectorXd init_Y = Eigen::VectorXd::Zero(FS.n_nodes_);
    Eigen::VectorXd init_T = Eigen::VectorXd::Zero(FS.n_nodes_tension_);
    init_Y[init_Y.size() - 1 - 3] = mlength / 2.0;
    init_Y[init_Y.size() - 1 - 2] = 1.0;
    Eigen::VectorXd XX(init_X.size() + init_Y.size() + init_T.size());
    XX << init_X, init_Y, init_T;

    // Try Divide and Construct
    auto Div = FS.DivideAndConstruct(XX, mlength);

    autodiff::VectorXreal YCtrue{{0.5, 0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    autodiff::VectorXreal YsCtrue{{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    EXPECT_TRUE(YCtrue.isApprox(Div.YC_));
    EXPECT_TRUE(YsCtrue.isApprox(Div.YsC_));
}

// Test the penalty forces
TEST(FiberChebysehvPenaltyAutodiff, real_forces) {
    // Create a fiber object
    int N = 20;
    int NT = N - 2;
    int Neq = N - 4;
    int NTeq = NT - 2;
    double mlength = 1.0;
    FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);

    // Taken from Julia for the first timestep of the funciton in a sheer flow to compare to
    autodiff::VectorXreal XX{{60.0480227998087770,   -101.9506826907408765, 51.9343787940473760,   -10.4540573251306164,
                              -11.7091066585494996,  16.2140161411610997,   -11.7083971699872880,  6.0289382372732394,
                              -2.4070215350084792,   0.6838614991858294,    -0.0049060254621093,   -0.1788380697556702,
                              0.1602479731360698,    -0.0931454880346660,   0.0424927898922256,    -0.0128601494773640,
                              0.2193973350388452,    0.4087291888305368,    0.4841441405005029,    -1.5750008132303601,
                              52.8657357932827736,   -102.2105217746640591, 92.6318267662486647,   -69.9190532376784688,
                              39.8751997353422922,   -16.1017047444886963,  3.2404279967474698,    1.5672021673638288,
                              -2.3049734804756610,   1.6231572964223722,    -0.8211937355941242,   0.3092362423873997,
                              -0.0745206052414949,   -0.0036665860741279,   0.0277860139814897,    -0.0176334813873533,
                              0.4561181687022006,    0.9214887152110773,    -0.0592689415721022,   -0.2571209346937166,
                              -874.5796455234896030, 1281.7605985693051025, -953.9504954075138130, 554.5044090342805703,
                              -210.8615366227862467, -5.9283405118789814,   94.4457731090606671,   -97.9709166148476669,
                              66.5837307017072249,   -33.6612389195228161,  12.2160734371203681,   -2.1248214329907982,
                              -1.1479555519597531,   1.5078442418778060,    -1.0374971493440193,   0.5394800388411124,
                              52.0019688053351885,   -29.9310303532931457}};
    autodiff::VectorXreal oldXX{
        {14.7463835307163826, -20.6417455684296982, -0.4814512200205823, 15.2029164004962176, -13.0711212011266600,
         5.6033741423131938,  -1.1745630201570518,  -0.0218081216966133, 0.0902497715598546,  -0.0288303077441598,
         0.0044113201835056,  -0.0001266765326215,  -0.0001003834834743, 0.0000258121148767,  -0.0000030338682357,
         0.0000000832824501,  0.1213134041173209,   0.2237146559560383,  0.2609178824818563,  -0.7097415557391460,
         -0.0000000000000058, 0.0000000000000155,   0.0000000000000049,  -0.0000000000000044, 0.0000000000000134,
         -0.0000000000000011, -0.0000000000000016,  0.0000000000000036,  0.0000000000000015,  -0.0000000000000011,
         0.0000000000000005,  -0.0000000000000011,  -0.0000000000000010, 0.0000000000000012,  0.0000000000000002,
         -0.0000000000000005, 0.5000000000000000,   1.0000000000000000,  -0.0000000000000000, 0.0000000000000003,
         0.0000000000000143,  0.0000000000003712,   0.0000000000000013,  0.0000000000001477,  0.0000000000000488,
         -0.0000000000000233, 0.0000000000000439,   0.0000000000000318,  -0.0000000000000579, -0.0000000000000182,
         -0.0000000000000174, -0.0000000000000363,  0.0000000000000318,  0.0000000000000120,  -0.0000000000000330,
         0.0000000000000127,  0.0000000000000201,   -0.0000000000000323}};

    // Create the Div and oDiv structures for the forces
    auto Div = FS.DivideAndConstruct(XX, mlength);
    auto oDiv = FS.DivideAndConstruct(oldXX, mlength);

    // Check that Div and oDiv were constructed properly
    autodiff::VectorXreal Div_XC_true{{0.2193973350388452, 0.2372251964598805, 0.0028417909692916, -0.0072575080268174,
                                       0.0049220682333773, -0.0019806415920415, 0.0006288075956914, -0.0001750150807689,
                                       0.0000305396679530, 0.0000020331302382, -0.0000038444786937, 0.0000017418982979,
                                       -0.0000006196113489, 0.0000002143828926, -0.0000000569414079,
                                       -0.0000000006979729}};
    autodiff::VectorXreal Div_YC_true{{0.4561181687022006, 0.4515625963068547, 0.0001020867602687, 0.0026684088836761,
                                       -0.0018531603341006, 0.0004543453149293, 0.0001019565868943, -0.0001282533679407,
                                       0.0000606097502972, -0.0000208524497103, 0.0000057801717048, -0.0000011094038048,
                                       -0.0000000278733446, 0.0000001455281717, -0.0000000952669703,
                                       0.0000000376847738}};
    autodiff::VectorXreal Div_TC_true{{52.0019688053351885, -37.6922710996160930, -17.1097648763923829,
                                       4.6566647371035907, -2.9161696507584343, 1.5595969754505641, -0.6775182679046713,
                                       0.2087423130572356, -0.0160981174585723, -0.0339240830782111, 0.0301621192556019,
                                       -0.0161984068697774, 0.0063719194087564, -0.0019731985562813,
                                       -0.0000379321437554, 0.0004487631672255}};

    EXPECT_TRUE(Div.XC_.isApprox(Div_XC_true));
    EXPECT_TRUE(Div.YC_.isApprox(Div_YC_true));
    EXPECT_TRUE(Div.TC_.isApprox(Div_TC_true));

    // Try to construct forces...
    auto [FxC, FyC, AFxC, AFyC] = skelly_fiber::FiberForces(Div, oDiv, 1.0, FS.n_equations_);

    autodiff::VectorXreal FxC_true{{-40.1841203785645718, 0.5017825766590462, 9.0712863694151622, -16.5145450775445219,
                                    9.5953464141813125, -3.6092715878098778, 1.4098766726509195, -0.4952018482858689,
                                    0.0657161709844420, 0.0336277649985792, -0.0253961520203569, 0.0106105495088178,
                                    -0.0040614511866837, 0.0015090770703443, -0.0003403408446132, -0.0000742960021206}};
    autodiff::VectorXreal FyC_true{{-82.7967661465759335, -96.5916771352022039, -1.7248030743707261, 7.9949733389512332,
                                    -4.8481528887073466, 0.8363392578963538, 0.5946793408762425, -0.5721292242440633,
                                    0.2952960524967616, -0.1129445946283010, 0.0327832984308377, -0.0055083108173924,
                                    -0.0011599296515784, 0.0015423860238323, -0.0008602239479789, 0.0003418622315936}};
    autodiff::VectorXreal AFxC_true{{-63.7824450161000698, -23.3035560357534166, 10.7836258968863987,
                                     -16.4955245904501027, 8.4703120664858762, -2.7735375407740817, 1.2387107757277087,
                                     -0.5936150768277532, 0.1517986930820068, 0.0001546629404403, -0.0167467662919035,
                                     0.0079503204822146, -0.0025509555127807, 0.0007378155286263, -0.0001355325156950,
                                     -0.0000403933705770}};
    autodiff::VectorXreal AFyC_true{{-175.5273251911966952, -193.7496147725789228, 0.4083470410761354,
                                     10.6736355347067597, -7.4126413364017729, 1.8173812597189283, 0.4078263475770978,
                                     -0.5130134717624768, 0.2424390011916278, -0.0834097988372393, 0.0231206868216767,
                                     -0.0044376152154424, -0.0001114933744596, 0.0005821126922170, -0.0003810678771097,
                                     0.0001507390982731}};

    EXPECT_TRUE(FxC.isApprox(FxC_true));
    EXPECT_TRUE(FyC.isApprox(FyC_true));
    EXPECT_TRUE(AFxC.isApprox(AFxC_true));
    EXPECT_TRUE(AFyC.isApprox(AFyC_true));
}

// ********************************************************************************************************************
// Physics tests
// See if we can do a full physics test
// ********************************************************************************************************************

// // Test a full sheer flow implementation
// TEST(FiberChebysehvPenaltyAutodiff, construction) {
//     // Create a fiber object
//     int N = 20;
//     int NT = N - 3;
//     int Neq = N - 4;
//     int NTeq = NT - 1;
//     double mlength = 1.0;
//     FiberChebyshevConstraintAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);
//     std::cout << FS;

//     // Now create our fiber in XYT
//     Eigen::VectorXd init_X = Eigen::VectorXd::Zero(FS.n_nodes_);
//     Eigen::VectorXd init_Y = Eigen::VectorXd::Zero(FS.n_nodes_);
//     Eigen::VectorXd init_T = Eigen::VectorXd::Zero(FS.n_nodes_tension_);
//     init_Y[init_Y.size() - 1 - 3] = mlength/2.0;
//     init_Y[init_Y.size() - 1 - 2] = 1.0;
//     Eigen::VectorXd XX(init_X.size() + init_Y.size() + init_T.size());
//     XX << init_X, init_Y, init_T;
//     std::cout << "Initial vector:\n" << XX << "\n    size: " << XX.size() << std::endl;
// }
