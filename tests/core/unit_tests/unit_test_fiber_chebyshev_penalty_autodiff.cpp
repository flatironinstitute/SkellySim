
/// \file unit_test_fiber_base.cpp
/// \brief Unit tests for FiberChebyshevPenalty class

// C++ includes
#include <iostream>
#include <memory>
#include <string>
#include <vector>

// skelly includes
#include <fiber_chebyshev_penalty_autodiff.hpp>
#include <msgpack.hpp>

// test files
#include "./mpi_environment.hpp"

// Test the penalty version constructor
TEST(FiberChebysehvPenaltyAutodiff, real_constructor) {
    // Create a fiber object
    int N = 20;
    int NT = N - 2;
    int Neq = N - 4;
    int NTeq = NT - 2;
    double mlength = 1.0;
    FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);

    // Now create our fiber in XYT
    Eigen::VectorXd init_X = Eigen::VectorXd::Zero(FS.n_nodes_);
    Eigen::VectorXd init_Y = Eigen::VectorXd::Zero(FS.n_nodes_);
    Eigen::VectorXd init_T = Eigen::VectorXd::Zero(FS.n_nodes_tension_);
    init_Y[init_Y.size() - 1 - 3] = mlength / 2.0;
    init_Y[init_Y.size() - 1 - 2] = 1.0;
    Eigen::VectorXd XX(init_X.size() + init_Y.size() + init_T.size());
    XX << init_X, init_Y, init_T;

    // Try Divide and Construct
    auto Div = FS.DivideAndConstruct(XX, mlength);

    autodiff::VectorXreal YCtrue{{0.5, 0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    autodiff::VectorXreal YsCtrue{{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    EXPECT_TRUE(YCtrue.isApprox(Div.YC_));
    EXPECT_TRUE(YsCtrue.isApprox(Div.YsC_));
}

// Test the penalty forces
TEST(FiberChebysehvPenaltyAutodiff, real_forces) {
    // Create a fiber object
    int N = 20;
    int NT = N - 2;
    int Neq = N - 4;
    int NTeq = NT - 2;
    double mlength = 1.0;
    FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);

    // Taken from Julia for the first timestep of the function in a sheer flow to compare to
    autodiff::VectorXreal XX{{60.0480227998087770,   -101.9506826907408765, 51.9343787940473760,   -10.4540573251306164,
                              -11.7091066585494996,  16.2140161411610997,   -11.7083971699872880,  6.0289382372732394,
                              -2.4070215350084792,   0.6838614991858294,    -0.0049060254621093,   -0.1788380697556702,
                              0.1602479731360698,    -0.0931454880346660,   0.0424927898922256,    -0.0128601494773640,
                              0.2193973350388452,    0.4087291888305368,    0.4841441405005029,    -1.5750008132303601,
                              52.8657357932827736,   -102.2105217746640591, 92.6318267662486647,   -69.9190532376784688,
                              39.8751997353422922,   -16.1017047444886963,  3.2404279967474698,    1.5672021673638288,
                              -2.3049734804756610,   1.6231572964223722,    -0.8211937355941242,   0.3092362423873997,
                              -0.0745206052414949,   -0.0036665860741279,   0.0277860139814897,    -0.0176334813873533,
                              0.4561181687022006,    0.9214887152110773,    -0.0592689415721022,   -0.2571209346937166,
                              -874.5796455234896030, 1281.7605985693051025, -953.9504954075138130, 554.5044090342805703,
                              -210.8615366227862467, -5.9283405118789814,   94.4457731090606671,   -97.9709166148476669,
                              66.5837307017072249,   -33.6612389195228161,  12.2160734371203681,   -2.1248214329907982,
                              -1.1479555519597531,   1.5078442418778060,    -1.0374971493440193,   0.5394800388411124,
                              52.0019688053351885,   -29.9310303532931457}};
    autodiff::VectorXreal oldXX{
        {14.7463835307163826, -20.6417455684296982, -0.4814512200205823, 15.2029164004962176, -13.0711212011266600,
         5.6033741423131938,  -1.1745630201570518,  -0.0218081216966133, 0.0902497715598546,  -0.0288303077441598,
         0.0044113201835056,  -0.0001266765326215,  -0.0001003834834743, 0.0000258121148767,  -0.0000030338682357,
         0.0000000832824501,  0.1213134041173209,   0.2237146559560383,  0.2609178824818563,  -0.7097415557391460,
         -0.0000000000000058, 0.0000000000000155,   0.0000000000000049,  -0.0000000000000044, 0.0000000000000134,
         -0.0000000000000011, -0.0000000000000016,  0.0000000000000036,  0.0000000000000015,  -0.0000000000000011,
         0.0000000000000005,  -0.0000000000000011,  -0.0000000000000010, 0.0000000000000012,  0.0000000000000002,
         -0.0000000000000005, 0.5000000000000000,   1.0000000000000000,  -0.0000000000000000, 0.0000000000000003,
         0.0000000000000143,  0.0000000000003712,   0.0000000000000013,  0.0000000000001477,  0.0000000000000488,
         -0.0000000000000233, 0.0000000000000439,   0.0000000000000318,  -0.0000000000000579, -0.0000000000000182,
         -0.0000000000000174, -0.0000000000000363,  0.0000000000000318,  0.0000000000000120,  -0.0000000000000330,
         0.0000000000000127,  0.0000000000000201,   -0.0000000000000323}};

    // Create the Div and oDiv structures for the forces
    auto Div = FS.DivideAndConstruct(XX, mlength);
    auto oDiv = FS.DivideAndConstruct(oldXX, mlength);

    // Check that Div and oDiv were constructed properly
    autodiff::VectorXreal Div_XC_true{{0.2193973350388452, 0.2372251964598805, 0.0028417909692916, -0.0072575080268174,
                                       0.0049220682333773, -0.0019806415920415, 0.0006288075956914, -0.0001750150807689,
                                       0.0000305396679530, 0.0000020331302382, -0.0000038444786937, 0.0000017418982979,
                                       -0.0000006196113489, 0.0000002143828926, -0.0000000569414079,
                                       -0.0000000006979729}};
    autodiff::VectorXreal Div_YC_true{{0.4561181687022006, 0.4515625963068547, 0.0001020867602687, 0.0026684088836761,
                                       -0.0018531603341006, 0.0004543453149293, 0.0001019565868943, -0.0001282533679407,
                                       0.0000606097502972, -0.0000208524497103, 0.0000057801717048, -0.0000011094038048,
                                       -0.0000000278733446, 0.0000001455281717, -0.0000000952669703,
                                       0.0000000376847738}};
    autodiff::VectorXreal Div_TC_true{{52.0019688053351885, -37.6922710996160930, -17.1097648763923829,
                                       4.6566647371035907, -2.9161696507584343, 1.5595969754505641, -0.6775182679046713,
                                       0.2087423130572356, -0.0160981174585723, -0.0339240830782111, 0.0301621192556019,
                                       -0.0161984068697774, 0.0063719194087564, -0.0019731985562813,
                                       -0.0000379321437554, 0.0004487631672255}};

    EXPECT_TRUE(Div.XC_.isApprox(Div_XC_true));
    EXPECT_TRUE(Div.YC_.isApprox(Div_YC_true));
    EXPECT_TRUE(Div.TC_.isApprox(Div_TC_true));

    // Try to construct forces...
    auto [FxC, FyC, AFxC, AFyC] = skelly_fiber::FiberForces(Div, oDiv, 1.0, FS.n_equations_);

    autodiff::VectorXreal FxC_true{{-40.1841203785645718, 0.5017825766590462, 9.0712863694151622, -16.5145450775445219,
                                    9.5953464141813125, -3.6092715878098778, 1.4098766726509195, -0.4952018482858689,
                                    0.0657161709844420, 0.0336277649985792, -0.0253961520203569, 0.0106105495088178,
                                    -0.0040614511866837, 0.0015090770703443, -0.0003403408446132, -0.0000742960021206}};
    autodiff::VectorXreal FyC_true{{-82.7967661465759335, -96.5916771352022039, -1.7248030743707261, 7.9949733389512332,
                                    -4.8481528887073466, 0.8363392578963538, 0.5946793408762425, -0.5721292242440633,
                                    0.2952960524967616, -0.1129445946283010, 0.0327832984308377, -0.0055083108173924,
                                    -0.0011599296515784, 0.0015423860238323, -0.0008602239479789, 0.0003418622315936}};
    autodiff::VectorXreal AFxC_true{{-63.7824450161000698, -23.3035560357534166, 10.7836258968863987,
                                     -16.4955245904501027, 8.4703120664858762, -2.7735375407740817, 1.2387107757277087,
                                     -0.5936150768277532, 0.1517986930820068, 0.0001546629404403, -0.0167467662919035,
                                     0.0079503204822146, -0.0025509555127807, 0.0007378155286263, -0.0001355325156950,
                                     -0.0000403933705770}};
    autodiff::VectorXreal AFyC_true{{-175.5273251911966952, -193.7496147725789228, 0.4083470410761354,
                                     10.6736355347067597, -7.4126413364017729, 1.8173812597189283, 0.4078263475770978,
                                     -0.5130134717624768, 0.2424390011916278, -0.0834097988372393, 0.0231206868216767,
                                     -0.0044376152154424, -0.0001114933744596, 0.0005821126922170, -0.0003810678771097,
                                     0.0001507390982731}};

    EXPECT_TRUE(FxC.isApprox(FxC_true));
    EXPECT_TRUE(FyC.isApprox(FyC_true));
    EXPECT_TRUE(AFxC.isApprox(AFxC_true));
    EXPECT_TRUE(AFyC.isApprox(AFyC_true));
}

// // Test the deflection objective from Julia
// TEST(FiberChebysehvPenaltyAutodiff, real_evolution_xy) {
//     // Create a fiber object
//     int N = 20;
//     int NT = N - 2;
//     int Neq = N - 4;
//     int NTeq = NT - 2;
//     double mlength = 1.0;
//     double zeta = 1000.0;
//     double dt = 1.0 / zeta / 4.0;
//     FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);

//     // Taken from Julia for the first timestep of the function in a sheer flow to compare to
//     autodiff::VectorXreal XX{{60.0480227998087770,   -101.9506826907408765, 51.9343787940473760,
//     -10.4540573251306164,
//                               -11.7091066585494996,  16.2140161411610997, -11.7083971699872880,  6.0289382372732394,
//                               -2.4070215350084792,   0.6838614991858294,    -0.0049060254621093, -0.1788380697556702,
//                               0.1602479731360698,    -0.0931454880346660,   0.0424927898922256, -0.0128601494773640,
//                               0.2193973350388452,    0.4087291888305368,    0.4841441405005029, -1.5750008132303601,
//                               52.8657357932827736,   -102.2105217746640591, 92.6318267662486647,
//                               -69.9190532376784688, 39.8751997353422922, -16.1017047444886963,  3.2404279967474698,
//                               1.5672021673638288, -2.3049734804756610,   1.6231572964223722,    -0.8211937355941242,
//                               0.3092362423873997, -0.0745206052414949,   -0.0036665860741279,   0.0277860139814897,
//                               -0.0176334813873533, 0.4561181687022006,    0.9214887152110773,    -0.0592689415721022,
//                               -0.2571209346937166, -874.5796455234896030, 1281.7605985693051025,
//                               -953.9504954075138130, 554.5044090342805703, -210.8615366227862467,
//                               -5.9283405118789814,   94.4457731090606671,   -97.9709166148476669,
//                               66.5837307017072249,   -33.6612389195228161,  12.2160734371203681, -2.1248214329907982,
//                               -1.1479555519597531,   1.5078442418778060,    -1.0374971493440193, 0.5394800388411124,
//                               52.0019688053351885,   -29.9310303532931457}};
//     autodiff::VectorXreal oldXX{
//         {14.7463835307163826, -20.6417455684296982, -0.4814512200205823, 15.2029164004962176, -13.0711212011266600,
//          5.6033741423131938,  -1.1745630201570518,  -0.0218081216966133, 0.0902497715598546,  -0.0288303077441598,
//          0.0044113201835056,  -0.0001266765326215,  -0.0001003834834743, 0.0000258121148767,  -0.0000030338682357,
//          0.0000000832824501,  0.1213134041173209,   0.2237146559560383,  0.2609178824818563,  -0.7097415557391460,
//          -0.0000000000000058, 0.0000000000000155,   0.0000000000000049,  -0.0000000000000044, 0.0000000000000134,
//          -0.0000000000000011, -0.0000000000000016,  0.0000000000000036,  0.0000000000000015,  -0.0000000000000011,
//          0.0000000000000005,  -0.0000000000000011,  -0.0000000000000010, 0.0000000000000012,  0.0000000000000002,
//          -0.0000000000000005, 0.5000000000000000,   1.0000000000000000,  -0.0000000000000000, 0.0000000000000003,
//          0.0000000000000143,  0.0000000000003712,   0.0000000000000013,  0.0000000000001477,  0.0000000000000488,
//          -0.0000000000000233, 0.0000000000000439,   0.0000000000000318,  -0.0000000000000579, -0.0000000000000182,
//          -0.0000000000000174, -0.0000000000000363,  0.0000000000000318,  0.0000000000000120,  -0.0000000000000330,
//          0.0000000000000127,  0.0000000000000201,   -0.0000000000000323}};

//     // Create the Div and oDiv structures for the forces
//     auto Div = FS.DivideAndConstruct(XX, mlength);
//     auto oDiv = FS.DivideAndConstruct(oldXX, mlength);

//     // Try to construct forces...
//     auto [FxC, FyC, AFxC, AFyC] = skelly_fiber::FiberForces(Div, oDiv, 1.0, FS.n_equations_);

//     // Try to construct the flow
//     autodiff::VectorXreal UC = zeta * Div.YC_;
//     autodiff::VectorXreal VC = autodiff::VectorXreal::Zero(Div.YC_.size());

//     // Get the evolution equations
//     auto [eqXC, eqYC] = skelly_fiber::FiberEvolution(AFxC, AFyC, Div, oDiv, UC, VC, dt);

//     // XXX Currently this fails, so write out the equations, so we can compare to what we expected from Julia
//     Eigen::IOFormat ColumnAsRowFmt(Eigen::StreamPrecision, 0, ",", ",", "", "", "[", "]");
//     std::cout << "eqXC = " << eqXC.format(ColumnAsRowFmt) << std::endl;
//     std::cout << "eqYC = " << eqYC.format(ColumnAsRowFmt) << std::endl;

//     autodiff::VectorXreal eqXC_true{
//         {-7.632783294297951e-16, -2.1094237467877974e-15, -2.1687296056227545e-15, 2.242130092700023e-16,
//          -6.231994087446679e-16, -2.0391674460107367e-15, -3.326982786489019e-15, -9.270902662640405e-16,
//          -1.834188860906985e-15, -5.399593634356197e-15, -1.0565238886263125e-15, -4.610671435387837e-15,
//          -5.440738024849781e-15, -3.7911695487329455e-15, -3.430589287167387e-15, -3.1364835329386333e-15}};
//     autodiff::VectorXreal eqYC_true{
//         {-2.7755575615628914e-16, -5.551115123125783e-16, -3.9445131877483294e-16, -5.570752943877526e-16,
//          -1.9899901030037113e-16, -4.1278443596493896e-16, -6.505119120294506e-18, -6.909897680852266e-17,
//          -7.293982911669084e-16, -9.942447639050947e-16, -6.116546983524829e-16, -9.409119737740971e-16,
//          -1.0044427488318604e-15, -1.3321005710282112e-15, -1.034053459335586e-15, -7.724497061744926e-16}};
//     EXPECT_TRUE(eqXC.isApprox(eqXC_true, 1e-6));
//     EXPECT_TRUE(eqYC.isApprox(eqYC_true, 1e-6));
// }

// // Test the tension equation
// TEST(FiberChebysehvPenaltyAutodiff, real_tension) {
//     // Create a fiber object
//     int N = 20;
//     int NT = N - 2;
//     int Neq = N - 4;
//     int NTeq = NT - 2;
//     double mlength = 1.0;
//     double zeta = 1000.0;
//     double dt = 1.0 / zeta / 4.0;
//     FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);

//     // Taken from Julia for the first timestep of the function in a sheer flow to compare to
//     autodiff::VectorXreal XX{{60.0480227998087770,   -101.9506826907408765, 51.9343787940473760,
//     -10.4540573251306164,
//                               -11.7091066585494996,  16.2140161411610997, -11.7083971699872880,  6.0289382372732394,
//                               -2.4070215350084792,   0.6838614991858294,    -0.0049060254621093, -0.1788380697556702,
//                               0.1602479731360698,    -0.0931454880346660,   0.0424927898922256, -0.0128601494773640,
//                               0.2193973350388452,    0.4087291888305368,    0.4841441405005029, -1.5750008132303601,
//                               52.8657357932827736,   -102.2105217746640591, 92.6318267662486647,
//                               -69.9190532376784688, 39.8751997353422922, -16.1017047444886963,  3.2404279967474698,
//                               1.5672021673638288, -2.3049734804756610,   1.6231572964223722,    -0.8211937355941242,
//                               0.3092362423873997, -0.0745206052414949,   -0.0036665860741279,   0.0277860139814897,
//                               -0.0176334813873533, 0.4561181687022006,    0.9214887152110773,    -0.0592689415721022,
//                               -0.2571209346937166, -874.5796455234896030, 1281.7605985693051025,
//                               -953.9504954075138130, 554.5044090342805703, -210.8615366227862467,
//                               -5.9283405118789814,   94.4457731090606671,   -97.9709166148476669,
//                               66.5837307017072249,   -33.6612389195228161,  12.2160734371203681, -2.1248214329907982,
//                               -1.1479555519597531,   1.5078442418778060,    -1.0374971493440193, 0.5394800388411124,
//                               52.0019688053351885,   -29.9310303532931457}};
//     autodiff::VectorXreal oldXX{
//         {14.7463835307163826, -20.6417455684296982, -0.4814512200205823, 15.2029164004962176, -13.0711212011266600,
//          5.6033741423131938,  -1.1745630201570518,  -0.0218081216966133, 0.0902497715598546,  -0.0288303077441598,
//          0.0044113201835056,  -0.0001266765326215,  -0.0001003834834743, 0.0000258121148767,  -0.0000030338682357,
//          0.0000000832824501,  0.1213134041173209,   0.2237146559560383,  0.2609178824818563,  -0.7097415557391460,
//          -0.0000000000000058, 0.0000000000000155,   0.0000000000000049,  -0.0000000000000044, 0.0000000000000134,
//          -0.0000000000000011, -0.0000000000000016,  0.0000000000000036,  0.0000000000000015,  -0.0000000000000011,
//          0.0000000000000005,  -0.0000000000000011,  -0.0000000000000010, 0.0000000000000012,  0.0000000000000002,
//          -0.0000000000000005, 0.5000000000000000,   1.0000000000000000,  -0.0000000000000000, 0.0000000000000003,
//          0.0000000000000143,  0.0000000000003712,   0.0000000000000013,  0.0000000000001477,  0.0000000000000488,
//          -0.0000000000000233, 0.0000000000000439,   0.0000000000000318,  -0.0000000000000579, -0.0000000000000182,
//          -0.0000000000000174, -0.0000000000000363,  0.0000000000000318,  0.0000000000000120,  -0.0000000000000330,
//          0.0000000000000127,  0.0000000000000201,   -0.0000000000000323}};

//     // Create the Div and oDiv structures for the forces
//     auto Div = FS.DivideAndConstruct(XX, mlength);
//     auto oDiv = FS.DivideAndConstruct(oldXX, mlength);

//     // Try to construct the flow
//     autodiff::VectorXreal UsC = zeta * Div.YsC_;
//     autodiff::VectorXreal VsC = autodiff::VectorXreal::Zero(Div.YsC_.size());
//     autodiff::VectorXreal oUsC = zeta * oDiv.YC_;
//     autodiff::VectorXreal oVsC = autodiff::VectorXreal::Zero(oDiv.YsC_.size());

//     autodiff::VectorXreal eqTC =
//         skelly_fiber::FiberPenaltyTension(Div, oDiv, UsC, VsC, oUsC, oVsC, dt, FS.n_equations_tension_);

//     // XXX Currently this fails, so write out the equations, so we can compare to what we expected from Julia
//     Eigen::IOFormat ColumnAsRowFmt(Eigen::StreamPrecision, 0, ",", ",", "", "", "[", "]");
//     std::cout << "eqTC = " << eqTC.format(ColumnAsRowFmt) << std::endl;

//     autodiff::VectorXreal eqTC_true{
//         {-0.00000000000019428902930940209165, 0.00000000000003686493568062128302, 0.00000000000010479008103747587113,
//          -0.00000000000005777659539582771642, -0.00000000000022638566368250633690,
//          -0.00000000000006333101921228000159, -0.00000000000009057622961147390087,
//          0.00000000000006400294829630100709, -0.00000000000003925231146709456726, 0.00000000000012660173634986619932,
//          0.00000000000006490461314998491460, -0.00000000000000298782829892356240,
//          -0.00000000000003368717510216347958, -0.00000000000015315677922394524796,
//          -0.00000000000032561460194561578268, -0.00000000000009659957862247440106}};

//     EXPECT_TRUE(eqTC.isApprox(eqTC_true, 1e-6));
// }

// // Test the clamped boundary conditions
// TEST(FiberChebysehvPenaltyAutodiff, real_clampedbc) {
//     // Create a fiber object
//     int N = 20;
//     int NT = N - 2;
//     int Neq = N - 4;
//     int NTeq = NT - 2;
//     double mlength = 1.0;
//     FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);

//     // Taken from Julia for the first timestep of the function in a sheer flow to compare to
//     autodiff::VectorXreal XX{{60.0480227998087770,   -101.9506826907408765, 51.9343787940473760,
//     -10.4540573251306164,
//                               -11.7091066585494996,  16.2140161411610997, -11.7083971699872880,  6.0289382372732394,
//                               -2.4070215350084792,   0.6838614991858294,    -0.0049060254621093, -0.1788380697556702,
//                               0.1602479731360698,    -0.0931454880346660,   0.0424927898922256, -0.0128601494773640,
//                               0.2193973350388452,    0.4087291888305368,    0.4841441405005029, -1.5750008132303601,
//                               52.8657357932827736,   -102.2105217746640591, 92.6318267662486647,
//                               -69.9190532376784688, 39.8751997353422922, -16.1017047444886963,  3.2404279967474698,
//                               1.5672021673638288, -2.3049734804756610,   1.6231572964223722,    -0.8211937355941242,
//                               0.3092362423873997, -0.0745206052414949,   -0.0036665860741279,   0.0277860139814897,
//                               -0.0176334813873533, 0.4561181687022006,    0.9214887152110773,    -0.0592689415721022,
//                               -0.2571209346937166, -874.5796455234896030, 1281.7605985693051025,
//                               -953.9504954075138130, 554.5044090342805703, -210.8615366227862467,
//                               -5.9283405118789814,   94.4457731090606671,   -97.9709166148476669,
//                               66.5837307017072249,   -33.6612389195228161,  12.2160734371203681, -2.1248214329907982,
//                               -1.1479555519597531,   1.5078442418778060,    -1.0374971493440193, 0.5394800388411124,
//                               52.0019688053351885,   -29.9310303532931457}};
//     autodiff::VectorXreal oldXX{
//         {14.7463835307163826, -20.6417455684296982, -0.4814512200205823, 15.2029164004962176, -13.0711212011266600,
//          5.6033741423131938,  -1.1745630201570518,  -0.0218081216966133, 0.0902497715598546,  -0.0288303077441598,
//          0.0044113201835056,  -0.0001266765326215,  -0.0001003834834743, 0.0000258121148767,  -0.0000030338682357,
//          0.0000000832824501,  0.1213134041173209,   0.2237146559560383,  0.2609178824818563,  -0.7097415557391460,
//          -0.0000000000000058, 0.0000000000000155,   0.0000000000000049,  -0.0000000000000044, 0.0000000000000134,
//          -0.0000000000000011, -0.0000000000000016,  0.0000000000000036,  0.0000000000000015,  -0.0000000000000011,
//          0.0000000000000005,  -0.0000000000000011,  -0.0000000000000010, 0.0000000000000012,  0.0000000000000002,
//          -0.0000000000000005, 0.5000000000000000,   1.0000000000000000,  -0.0000000000000000, 0.0000000000000003,
//          0.0000000000000143,  0.0000000000003712,   0.0000000000000013,  0.0000000000001477,  0.0000000000000488,
//          -0.0000000000000233, 0.0000000000000439,   0.0000000000000318,  -0.0000000000000579, -0.0000000000000182,
//          -0.0000000000000174, -0.0000000000000363,  0.0000000000000318,  0.0000000000000120,  -0.0000000000000330,
//          0.0000000000000127,  0.0000000000000201,   -0.0000000000000323}};

//     // Create the Div and oDiv structures for the forces
//     auto Div = FS.DivideAndConstruct(XX, mlength);
//     auto oDiv = FS.DivideAndConstruct(oldXX, mlength);

//     // Get the clamped boundary conditions
//     autodiff::VectorXreal cposition{{0.0, 0.0}};
//     autodiff::VectorXreal cdirector{{0.0, 1.0}};
//     autodiff::VectorXreal X1;
//     autodiff::VectorXreal X2;
//     autodiff::VectorXreal Y1;
//     autodiff::VectorXreal Y2;
//     autodiff::VectorXreal T;
//     FiberBoundaryCondition<autodiff::real> BCL = skelly_fiber::ClampedBC<autodiff::real, autodiff::VectorXreal>(
//         Div, oDiv, skelly_fiber::FSIDE::left, cposition, cdirector);

//     EXPECT_DOUBLE_EQ(-3.608224830031759e-16, BCL.X1_.val());
//     EXPECT_DOUBLE_EQ(-3.3306690738754696e-16, BCL.X2_.val());
//     EXPECT_DOUBLE_EQ(1.1102230246251565e-16, BCL.Y1_.val());
//     EXPECT_DOUBLE_EQ(2.220446049250313e-16, BCL.Y2_.val());
//     EXPECT_DOUBLE_EQ(-1.7053025658242404e-13, BCL.T_.val());
// }

// ********************************************************************************************************************
// Physics tests
// See if we can do a full physics test
// ********************************************************************************************************************

// Test a full sheer flow implementation
TEST(FiberChebysehvPenaltyAutodiff, deflection_objective) {
    // Create a fiber object
    int N = 20;
    int NT = N - 2;
    int Neq = N - 4;
    int NTeq = NT - 2;
    double mlength = 1.0;
    double zeta = 1000.0;
    double dt = 1.0 / zeta / 4.0;
    FiberChebyshevPenaltyAutodiff<autodiff::VectorXreal> FS(N, NT, Neq, NTeq);
    std::cout << FS;
    std::cout << "dt = " << dt << std::endl;

    // Now create our fiber in XYT
    autodiff::VectorXreal init_X = Eigen::VectorXd::Zero(FS.n_nodes_);
    autodiff::VectorXreal init_Y = Eigen::VectorXd::Zero(FS.n_nodes_);
    autodiff::VectorXreal init_T = Eigen::VectorXd::Zero(FS.n_nodes_tension_);
    init_Y[init_Y.size() - 1 - 3] = mlength / 2.0;
    init_Y[init_Y.size() - 1 - 2] = 1.0;
    autodiff::VectorXreal XX(init_X.size() + init_Y.size() + init_T.size());
    XX << init_X, init_Y, init_T;
    autodiff::VectorXreal oldXX = XX;
    std::cout << "Initial vector:\n" << XX << "\n    size: " << XX.size() << std::endl;

    // Call the deflection objective once
    autodiff::VectorXreal deflectionXX1 = FS.SheerDeflectionObjective(XX, oldXX, mlength, zeta, dt);

    // Write out things if we want to...
    Eigen::IOFormat ColumnAsRowFmt(Eigen::StreamPrecision, 0, ",", ",", "", "", "[", "]");
    std::cout << "deflectionXX1: " << deflectionXX1 << std::endl;

    // Try the 'next' timestep
    autodiff::VectorXreal XXnext{{14.746383530716432,
                                  -20.641745568429613,
                                  -0.4814512200204801,
                                  15.202916400496415,
                                  -13.071121201126644,
                                  5.603374142313219,
                                  -1.174563020157052,
                                  -0.021808121696615723,
                                  0.09024977155985386,
                                  -0.028830307744160278,
                                  0.004411320183506385,
                                  -0.00012667653262006716,
                                  -0.00010038348347489779,
                                  2.581211487671164e-5,
                                  -3.03386823651286e-6,
                                  8.328245128928405e-8,
                                  0.12131340411732089,
                                  0.22371465595603862,
                                  0.2609178824818568,
                                  -0.7097415557391469,
                                  -8.342436074747466e-16,
                                  -1.913496432457208e-15,
                                  -2.8547704661768873e-15,
                                  -4.609304259762747e-15,
                                  -1.1231472514461446e-15,
                                  2.1090162254568258e-15,
                                  2.4979209492549252e-15,
                                  1.083268504729812e-15,
                                  1.010361278375407e-15,
                                  1.425320026692271e-15,
                                  -1.6114343509210892e-15,
                                  -1.1160903476290877e-15,
                                  -1.5621324674264817e-15,
                                  -2.8031518712223773e-15,
                                  1.3645121507114145e-15,
                                  2.7115043889586697e-15,
                                  0.5,
                                  1.0,
                                  1.2057633420079187e-17,
                                  -1.0044569607507868e-17,
                                  5.5741286701143245e-14,
                                  -1.499318796998502e-14,
                                  -8.03246864687803e-15,
                                  2.0086276663941686e-14,
                                  1.0241729309173934e-13,
                                  3.0460060629685295e-14,
                                  4.737477231939986e-14,
                                  -3.134848263866237e-14,
                                  1.9378033716741707e-14,
                                  -6.316396010506554e-14,
                                  -3.231695791815389e-14,
                                  1.4621180750810367e-15,
                                  1.6884976792610257e-14,
                                  7.649553502485387e-14,
                                  1.6274878215516399e-13,
                                  4.833329027985141e-14,
                                  -1.8928430114451824e-14,
                                  2.7928337365239425e-14}};

    // Call on next timestep
    autodiff::VectorXreal deflectionXX2 = FS.SheerDeflectionObjective(XXnext, oldXX, mlength, zeta, dt);
    std::cout << "deflectionXX2: " << deflectionXX2 << std::endl;
}
